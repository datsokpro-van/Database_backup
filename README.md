# Домашнее задание к занятию "`Резервное копирование`" - `Дацко Иван`


### Инструкция по выполнению домашнего задания

   1. Сделайте `fork` данного репозитория к себе в Github и переименуйте его по названию или номеру занятия, например, https://github.com/имя-вашего-репозитория/git-hw или  https://github.com/имя-вашего-репозитория/7-1-ansible-hw).
   2. Выполните клонирование данного репозитория к себе на ПК с помощью команды `git clone`.
   3. Выполните домашнее задание и заполните у себя локально этот файл README.md:
      - впишите вверху название занятия и вашу фамилию и имя
      - в каждом задании добавьте решение в требуемом виде (текст/код/скриншоты/ссылка)
      - для корректного добавления скриншотов воспользуйтесь [инструкцией "Как вставить скриншот в шаблон с решением](https://github.com/netology-code/sys-pattern-homework/blob/main/screen-instruction.md)
      - при оформлении используйте возможности языка разметки md (коротко об этом можно посмотреть в [инструкции  по MarkDown](https://github.com/netology-code/sys-pattern-homework/blob/main/md-instruction.md))
   4. После завершения работы над домашним заданием сделайте коммит (`git commit -m "comment"`) и отправьте его на Github (`git push origin`);
   5. Для проверки домашнего задания преподавателем в личном кабинете прикрепите и отправьте ссылку на решение в виде md-файла в вашем Github.
   6. Любые вопросы по выполнению заданий спрашивайте в чате учебной группы и/или в разделе “Вопросы по заданию” в личном кабинете.
   
Желаем успехов в выполнении домашнего задания!
   
### Дополнительные материалы, которые могут быть полезны для выполнения задания

1. [Руководство по оформлению Markdown файлов](https://gist.github.com/Jekins/2bf2d0638163f1294637#Code)

---

## Задание 1. Резервное копирование

##### 1.1. Восстановление данных за предыдущий день
Подходит дифференциальный бэкап в связке с полным.
Полный бэкап делается раз в неделю (например, в воскресенье), а каждый день после — дифференциальный, который содержит все изменения с момента последнего полного.
Для восстановления за понедельник: разворачиваем воскресную полную копию + понедельничную дифференциальную. Получаем состояние на конец дня.

##### 1.2. Восстановление за час до поломки
Требуется горячее резервное копирование с поддержкой point-in-time recovery (PITR).
Делаем полный бэкап + архивируем журналы транзакций (WAL в PostgreSQL, binary log в MySQL).
При восстановлении: накатываем полный бэкап, затем журналы до нужного момента (например, 2025-10-25 05:00:00).

##### 1.3. Моментальное переключение при поломке*
Да, возможно — с помощью репликации в режиме высокой доступности (HA).
Например, через master-slave с автоматическим failover (с использованием Patroni, Orchestrator и т.п.).
При падении master один из slave автоматически становится новым master, и клиенты переключаются на него за секунды.
Но важно: репликация — это не замена бэкапам, так как логические ошибки (например, DROP DATABASE) тоже реплицируются.

## Задание 2. PostgreSQL

##### 2.1. Пример команд
Резервная копия:
```pg_dump -U postgres -F c -f backup.dump my_db```

Восстановление:
```pg_restore -U postgres -d my_db backup.dump```

##### 2.1. Автоматизация*
Да, можно. Например, через cron:
```0 2 * * * pg_dump -U postgres my_db -F c -f /backups/my_db_$(date +\%F).dump```

Или использовать специализированные инструменты: pgBackRest, Barman, которые поддерживают инкрементные бэкапы, шифрование и проверку целостности.

## Задание 3. MySQL

##### 3.1. Инкрементное резервное копирование
В MySQL «инкрементный бэкап» = архив binary log файлов.
Сначала делаем полный бэкап: 
```mysqldump --single-transaction --master-data=2 -u root -p my_db > full.sql```

Затем сохраняем binary log файлы (mysql-bin.000001, и т.д.).
Для восстановления:

```mysql -u root -p my_db < full.sql
mysqlbinlog mysql-bin.000002 | mysql -u root -p```

Альтернатива — Percona XtraBackup, который поддерживает true инкрементные бэкапы на уровне InnoDB.

##### 3.1. Преимущество реплики перед бэкапом*
Реплика даёт:

почти мгновенное переключение при сбое (RTO ≈ секунды),
возможность обслуживать запросы на чтение даже при падении master,
непрерывную синхронизацию без downtime.
Но не защищает от логических ошибок, поэтому бэкапы всё равно нужны.

